---
title: '코딩테스트 풀이 8'
description: '23973 - [표적지 옮기기]'
date: '2024-09-30'
thumbnail: 'https://drive.google.com/thumbnail?id=1_i9hGGl4pc-AjE6p2U0N4cOb-bYdXi5X&sz=w1000'
hashtags: '코딩테스트'
---

## 백준 실버 II [<a href="https://www.acmicpc.net/problem/1245" target="_blank" className="a-mdx">표적지 옮기기</a>]

### 문제

효석이는 *N* x *M* 크기의 격자판 모양 사격판과 19 × 19 크기의 격자판 모양 표적지를 가지고 있다.

효석이는 사격판에 사격 연습을 하던 도중, 사격이 끝난 사격판 위에 표적지를 올려 1점부터 10점까지 정확히 한 번씩 점수를 얻을 수 있는지가 궁금해졌다.

궁금해하는 효석이를 위해 아래의 규칙을 지키면서 표적지의 중심인 10점 칸이 사격판의 어떤 칸 위에 있어야 하는지 구해주자.

- 사격판과 표적지 모두 격자 한 칸의 크기는 1 x 1로 동일하다.
- 사격판의 *i*행 *j*열 칸은 (*i*, *j*)이며, 가장 왼쪽 상단 칸은 (0, 0), 가장 오른쪽 하단 칸은 (*N*-1, *M*-1)이다.
- 사격판 위에 표적지를 올려 사격이 명중한 칸에 해당하는 점수를 얻을 수 있다.
- 사격판은 회전시킬 수 없으며, 사격판 위에 표적지를 올릴 때는 격자선이 일치하도록 올려야 한다.
- 표적지와 사격판은 일부만 겹쳐도 된다.
- 아래의 그림은 표적지와 점수를 나타낸 그림이다.

<img className="rounded-xl" src={"https://upload.acmicpc.net/1a079ad1-631f-4502-8192-34d93dd29fcc/"} alt={"image1"}/>


### 입력

첫째 줄에 사격판의 크기를 나타내는 정수 *N*과 *M*이 주어진다. (1 ≤ *N*, *M* ≤ 2,500)

다음 *N*개의 줄에는 사격판의 정보가 주어진다. 0은 사격이 명중하지 않은 칸을, 1은 사격이 명중한 칸을 의미한다. 사격이 명중한 칸의 개수는 최대 100,000개이다.

### 출력

표적지의 중심 칸이 위치해야 하는 사격판의 칸의 행과 열 번호를 출력한다. 가능한 정답이 여러가지인 경우에는 아무거나 출력한다. 가능한 정답이 없다면 -1을 출력한다.

### 예제

#### 입력 1

10 10
1000000000
0100000000
0010000000
0001000000
0000100000
0000010000
0000001000
0000000100
0000000010
0000000001

#### 출력 1

0 0

#### 입력 2

10 10
1000000000
0100000000
0010000000
0001000000
0000100000
0000010000
0000001000
0000000100
0000000010
0000000011

#### 출력 2

-1

---

## 풀이 과정

### 브루트 포스

모든 칸에 대해서 표적지 중심으로 설정했을 때, 점수를 정확히 1번씩 획득했는지 확인하면 된다.

*N*과 *M*의 최댓값은 2,500이고 표적지의 크기는 19 x 19이다. 즉, 각 경우마다 19 x 19 = 361회의 검증이 필요하고 2,500 x 2,500 = 6,250,000의 경우가 있다. 총 연산 횟수는 361 x 6,250,000 = 2,256,250,000으로 브루트 포스로는 풀이가 불가능해 보인다.

하지만 여기서 약간의 트릭을 쓰면 경우의 수를 크게 줄일 수 있다. 표적지의 중심인 10점은 표적지에서 1개밖에 없다. 그렇다는 것은 표적지 중심은 반드시 명중했어야 한다는 것이다. 다시 말하면 표적지의 중심이 될 수 있는 위치는 명중한 자리밖에 안되는 것이다. 최대 명중 개수는 100,000개이므로 확인해야 할 경우의 수가 크게 줄었다. 총 연산 횟수는 100,000 x 361 = 36,100,000으로 충분히 풀이가 가능하다.

### 점수 구하기

표적지의 중심을 잡았다면 점수를 어떻게 구할까? 경우를 줄여서 중심이 3점이고 2점, 1점이 있는 표적지를 생각해보자.

| 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|
| 1 | 1 | 1 | 1 | 1 |
| 1 | 2 | 2 | 2 | 1 |
| 1 | 2 | 3 | 2 | 1 |
| 1 | 2 | 2 | 2 | 1 |
| 1 | 1 | 1 | 1 | 1 |

특정 위치의 좌표를 중심을 기준으로 얼마나 떨어져 있는지 나타내면 다음과 같다.

| 1        | 2        | 3       | 4       | 5       |
|----------|----------|---------|---------|---------|
| (-2, -2) | (-2, -1) | (-2, 0) | (-2, 1) | (-2, 2) |
| (-1, -2) | (-1, -1) | (-1, 0) | (-1, 1) | (-1, 2) |
| (0, -2)  | (0, -1)  | (0, 0)  | (0, 1)  | (0, 2)  |
| (1, -2)  | (1, -1)  | (1, 0)  | (1, 1)  | (1, 2)  |
| (2, -2)  | (2, -1)  | (2, 0)  | (2, 1)  | (2, 2)  |

여기서 각 위치마다 x, y 좌표의 절댓값 중 더 큰값만을 나타내면 다음과 같다.

| 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|
| 2 | 2 | 2 | 2 | 2 |
| 2 | 1 | 1 | 1 | 2 |
| 2 | 1 | 0 | 1 | 2 |
| 2 | 1 | 1 | 1 | 2 |
| 2 | 2 | 2 | 2 | 2 |

즉, 중심을 기준으로 했을 때 (최대 점수) - (x, y좌표의 절댓값 중 더 큰값) 으로 해당 칸의 점수를 구할 수 있다.

## 정답

```java
import java.io.*;

public class Main {
    private static final BufferedReader BR = new BufferedReader(new InputStreamReader(System.in));

    private static int N;
    private static int M;
    private static String[] shooting;

    public static void main(String[] args) throws IOException {
        String[] input = BR.readLine().split(" ");
        N = Integer.parseInt(input[0]);
        M = Integer.parseInt(input[1]);
        shooting = new String[N];
        for (int n = 0; n < N; n++) {
            shooting[n] = BR.readLine();
        }

        for (int n = 0; n < N; n++) {
            for (int m = 0; m < M; m++) {
                // 중앙이 명중했을 때만 확인한다.
                if (shooting[n].charAt(m) == '1') test(n, m);
            }
        }
        System.out.println(-1);
    }

    private static void test(int n, int m) {
        boolean[] scoreList = new boolean[10]; // 획득한 점수 기록
        // 19 x 19 크기이므로 -9 ~ 9까지 확인한다.
        for (int x = -9; x <= 9; x++) {
            for (int y = -9; y <= 9; y++) {
                int nn = n + x;
                int nm = m + y;
                // 올바른 좌표이고 명중했다면
                if (0 <= nn && nn < N && 0 <= nm && nm < M && shooting[nn].charAt(nm) == '1') {
                    int score = 9 - Math.max(Math.abs(x), Math.abs(y));
                    if (scoreList[score]) return; // 이미 획득한 점수라면 함수를 종료한다.
                    scoreList[score] = true;
                }
            }
        }
        // 모든 점수를 획득했는지 확인한다.
        for (boolean b : scoreList) {
            if (!b) return;
        }
        // 모든 점수를 획득했다면 좌표를 출력하고 프로그램을 종료한다.
        System.out.println(n + " " + m);
        System.exit(0);
    }
}
```

---