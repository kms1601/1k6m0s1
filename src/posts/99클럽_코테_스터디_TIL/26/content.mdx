---
title: '[99클럽 코테 스터디] - 26일차 TIL'
description: '26일차 문제 [개인정보 수집 유효기간]'
date: '2024-08-16'
thumbnail: 'https://drive.google.com/thumbnail?id=1mDmYgm9XHrcPotgzaxnSPRSrteq3nNHv&sz=w1000'
hashtags: '99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL'
---

## 오늘의 문제 - 프로그래머스 Lv.1 [<a href="https://school.programmers.co.kr/learn/courses/30/lessons/150370" target="_blank" className="a-mdx">개인정보 수집 유효기간</a>]

### 문제 설명

고객의 약관 동의를 얻어서 수집된 1~**n**번으로 분류되는 개인정보 **n**개가 있습니다. 약관 종류는 여러 가지 있으며 각 약관마다 개인정보 보관 유효기간이 정해져 있습니다. 당신은 각 개인정보가 어떤 약관으로 수집됐는지 알고 있습니다. 수집된 개인정보는 유효기간 전까지만 보관 가능하며, 유효기간이 지났다면 반드시 파기해야 합니다.

예를 들어, A라는 약관의 유효기간이 12 달이고, 2021년 1월 5일에 수집된 개인정보가 A약관으로 수집되었다면 해당 개인정보는 2022년 1월 4일까지 보관 가능하며 2022년 1월 5일부터 파기해야 할 개인정보입니다.
당신은 오늘 날짜로 파기해야 할 개인정보 번호들을 구하려 합니다.

모든 달은 28일까지 있다고 가정합니다.

다음은 오늘 날짜가 **2022.05.19**일 때의 예시입니다.

| 약관 종류 | 유효기간 |
|-------|------|
| A     | 6 달  |
| B     | 12 달 |
| C     | 3 달  |

| 번호 | 개인정보 수집 일자 | 약관 종류 |
|----|------------|-------|
| 1  | 2021.05.02 | A     |
| 2  | 2021.07.01 | B     |
| 3  | 2022.02.19 | C     |
| 4  | 2022.02.20 | C     |

- 첫 번째 개인정보는 A약관에 의해 2021년 11월 1일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 두 번째 개인정보는 B약관에 의해 2022년 6월 28일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
- 세 번째 개인정보는 C약관에 의해 2022년 5월 18일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 네 번째 개인정보는 C약관에 의해 2022년 5월 19일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.

따라서 파기해야 할 개인정보 번호는 [1, 3]입니다.

오늘 날짜를 의미하는 문자열 **today**, 약관의 유효기간을 담은 1차원 문자열 배열 **terms**와 수집된 개인정보의 정보를 담은 1차원 문자열 배열 **privacies**가 매개변수로 주어집니다. 이때 파기해야 할 개인정보의 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

### 제한사항

- **today**는 "**YYYY**.**MM**.**DD**" 형태로 오늘 날짜를 나타냅니다.
- 1 ≤ **terms**의 길이 ≤ 20
    - **terms**의 원소는 "**약관 종류** **유효기간**" 형태의 **약관 종류**와 **유효기간**을 공백 하나로 구분한 문자열입니다.
    - **약관 종류**는 **A**~**Z**중 알파벳 대문자 하나이며, **terms** 배열에서 **약관 종류**는 중복되지 않습니다.
    - **유효기간**은 개인정보를 보관할 수 있는 달 수를 나타내는 정수이며, 1 이상 100 이하입니다.
- 1 ≤ **privacies**의 길이 ≤ 100
    - **privacies[i]**는 **i+1**번 개인정보의 수집 일자와 약관 종류를 나타냅니다.
    - **privacies**의 원소는 "**날짜** **약관 종류**" 형태의 **날짜**와 **약관 종류**를 공백 하나로 구분한 문자열입니다.
    - **날짜**는 "**YYYY**.**MM**.**DD**" 형태의 개인정보가 수집된 날짜를 나타내며, **today** 이전의 날짜만 주어집니다.
    - **privacies**의 **약관 종류**는 항상 **terms**에 나타난 **약관 종류**만 주어집니다.
- **today**와 **privacies**에 등장하는 **날짜**의 **YYYY**는 연도, **MM**은 월, **DD**는 일을 나타내며 점(**.**) 하나로 구분되어 있습니다.
    - 2000 ≤ **YYYY** ≤ 2022
    - 1 ≤ **MM** ≤ 12
    - **MM**이 한 자릿수인 경우 앞에 0이 붙습니다.
    - 1 ≤ **DD** ≤ 28
    - **DD**가 한 자릿수인 경우 앞에 0이 붙습니다.
- 파기해야 할 개인정보가 하나 이상 존재하는 입력만 주어집니다.

### 입출력 예

| today        | terms                  | privacies                                                                        | result    |
|--------------|------------------------|----------------------------------------------------------------------------------|-----------|
| "2022.05.19" | ["A 6", "B 12", "C 3"] | ["2021.05.02 A", "2021.07.01 B", "2022.02.19 C", "2022.02.20 C"]                 | [1, 3]    |
| "2020.01.01" | ["Z 3", "D 5"]         | ["2019.01.01 D", "2019.11.15 Z", "2019.08.02 D", "2019.07.01 D", "2018.12.28 Z"] | [1, 4, 5] |

### 입출력 예 설명

#### 입출력 예 #1

문제 예시와 같습니다.

#### 입출력 예 #2

| 약관 종류 | 유효기간 |
|-------|------|
| Z     | 3 달  |
| D     | 5 달  |

| 번호 | 개인정보 수집 일자 | 약관 종류 |
|----|------------|-------|
| 1  | 2019.01.01 | D     |
| 2  | 2019.11.15 | Z     |
| 3  | 2019.08.02 | D     |
| 4  | 2019.07.01 | D     |
| 5  | 2018.12.28 | Z     |

오늘 날짜는 2020년 1월 1일입니다.

- 첫 번째 개인정보는 D약관에 의해 2019년 5월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 두 번째 개인정보는 Z약관에 의해 2020년 2월 14일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
- 세 번째 개인정보는 D약관에 의해 2020년 1월 1일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
- 네 번째 개인정보는 D약관에 의해 2019년 11월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 다섯 번째 개인정보는 Z약관에 의해 2019년 3월 27일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.

---

## 풀이 과정

문제에서 요구하는 사항을 만족하기 위해서는 다음과 같은 사항을 다룰 수 있는 클래스를 구현하면 된다.

1. 문자열 → 날짜 변환
2. 날짜에 특정 개월을 더해 유효기간 구하기
3. 오늘 날짜와 비교하기

### 날짜 변환

날짜 변환을 위해서 Date클래스를 정의하였다. "."을 기준으로 년월일을 분리할 수 있다. 주의할 점은 String.split 메소드는 인자로 정규표현식을 받기 때문에 .을 그대로 넣으면 와일드카드 문자로 인식한다. 그래서 이스케이프 문자를 이용하여 "\\."으로 인자를 주어야 한다.

```java
class Date {
    int year;
    int month;
    int day;

    Date(String date) {
        String[] split = date.split("\\.");
        year = Integer.parseInt(split[0]);
        month = Integer.parseInt(split[1]);
        day = Integer.parseInt(split[2]);
    }
}
```

### 유효기간 구하기

유효기간을 구하기 위해서는 월에 특정 개월을 더한 뒤, 그 값이 12를 넘었다면 년에 month / 12 만큼 더해주고 월은 month % 12를 해주면 된다. 주의할 점은 월이 12의 배수일때는 월이 12월이라는 의미이므로 년에 month / 12 - 1을 더하고 월은 12월로 해야 한다. 이 처리를 하지 않으면 17번 테스트케이스를 통과하지 못한다.

```java
// Date 클래스 메소드
public void addMonth(int month) {
    this.month += month;
    if (this.month > 12) {
        if (this.month % 12 == 0) {
            year += this.month / 12 - 1;
            this.month = 12;
        } else {
            year += this.month / 12;
            this.month %= 12;
        }
    }
}
```

### 오늘 날짜와 비교하기

Comparable 인터페이스를 상속하여 compareTo 메소드를 구현하였다.

```java
@Override
public int compareTo(Date d) {
    int dy = this.year - d.year;
    int dm = this.month - d.month;
    int dd = this.day - d.day;

    if (dy != 0) return dy;
    if (dm != 0) return dm;
    return dd;
}
```

### 정답

이제 Date클래스를 구현하였으므로 나머지 부분은 문제에서 요구하는 흐름대로 구현하면 된다. 약관은 문자 → 정수 형태의 HashMap으로 처리하였다. 폐기할 개인정보가 확인하기 전까지는 몇 개인지 알 수 없으므로 return값을 List{"<Integer>"}로 변경하여 풀이하였다.

```java
import java.util.*;

class Solution {
    class Date implements Comparable<Date> {
        int year;
        int month;
        int day;

        Date(String date) {
            String[] split = date.split("\\.");
            year = Integer.parseInt(split[0]);
            month = Integer.parseInt(split[1]);
            day = Integer.parseInt(split[2]);
        }

        public void addMonth(int month) {
            this.month += month;

            if (this.month > 12) {
                if (this.month % 12 == 0) {
                    year += this.month / 12 - 1;
                    this.month = 12;
                } else {
                    year += this.month / 12;
                    this.month %= 12;
                }
            }
        }

        @Override
        public int compareTo(Date d) {
            int dy = this.year - d.year;
            int dm = this.month - d.month;
            int dd = this.day - d.day;

            if (dy != 0) return dy;
            if (dm != 0) return dm;
            return dd;
        }
    }

    public List<Integer> solution(String today, String[] terms, String[] privacies) {
        Map<Character, Integer> termsList = new HashMap<>();
        StringTokenizer st;
        for (String term : terms) {
            st = new StringTokenizer(term);
            termsList.put(st.nextToken().charAt(0), Integer.parseInt(st.nextToken()));
        }

        Date t = new Date(today);
        List<Integer> answer = new ArrayList<>();
        for (int i = 0; i < privacies.length; i++) {
            st = new StringTokenizer(privacies[i]);
            Date date = new Date(st.nextToken());
            char term = st.nextToken().charAt(0);

            date.addMonth(termsList.get(term));
            if (date.compareTo(t) <= 0) answer.add(i + 1);
        }
        return answer;
    }
}
```

---