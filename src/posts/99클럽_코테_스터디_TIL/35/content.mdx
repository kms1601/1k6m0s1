---
title: '[99클럽 코테 스터디] - 35일차 TIL'
description: '35일차 문제 [퍼즐 조각 채우기]'
date: '2024-08-25'
thumbnail: 'https://drive.google.com/thumbnail?id=1mDmYgm9XHrcPotgzaxnSPRSrteq3nNHv&sz=w1000'
hashtags: '99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL'
---

## 오늘의 문제 - 프로그래머스 Lv.3 [<a href="https://school.programmers.co.kr/learn/courses/30/lessons/84021" target="_blank" className="a-mdx">퍼즐 조각 채우기</a>]

### 문제 설명

테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다.

- 조각은 한 번에 하나씩 채워 넣습니다.
- 조각을 회전시킬 수 있습니다.
- 조각을 뒤집을 수는 없습니다.
- 게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.

다음은 퍼즐 조각을 채우는 예시입니다.

![image1](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ab4d8aa2-f282-4764-bb46-84d405464b90/puzzle_5.png)

위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다.

이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다.

![image2](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/70e371ad-4306-412b-b53b-25208e52a513/puzzle_6.png)

- 3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다.
- 5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다.

다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다.

![image3](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dadd0bc1-8e38-4689-a480-26afa799a5a3/puzzle_7.png)

최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다.

현재 게임 보드의 상태 <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>, 테이블 위에 놓인 퍼즐 조각의 상태 <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>table</span>이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- 3 ≤ <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>의 행 길이 ≤ 50
- <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>의 각 열 길이 = <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>의 행 길이
    - 즉, 게임 보드는 정사각 격자 모양입니다.
    - <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>의 모든 원소는 0 또는 1입니다.
    - 0은 빈칸, 1은 이미 채워진 칸을 나타냅니다.
    - 퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.
- <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>table</span>의 행 길이 = <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>의 행 길이
- table의 각 열 길이 = table의 행 길이
    - 즉, 테이블은 <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>와 같은 크기의 정사각 격자 모양입니다.
    - <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>table</span>의 모든 원소는 0 또는 1입니다.
    - 0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다.
    - 퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.
- <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>game_board</span>에는 반드시 하나 이상의 빈칸이 있습니다.
- <span className={"bg-secondary dark:bg-secondary-dark p-1 rounded"}>table</span>에는 반드시 하나 이상의 블록이 놓여 있습니다.

### 입출력 예

| game_board                                                                            | table                                                                                 | result |
|---------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|--------|
| [[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]] | [[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]] | 14     |
| [[0,0,0],[1,1,0],[1,1,1]]                                                             | [[1,1,1],[1,0,0],[0,0,0]]                                                             | 0      |

### 입출력 예 설명

#### 입출력 예 #1

입력은 다음과 같은 형태이며, 문제의 예시와 같습니다.

![image4](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/653b44d8-0fa6-42f8-aa9d-ceca639b0ad4/puzzle_9.png)

#### 입출력 예 #2

블록의 회전은 가능하지만, 뒤집을 수는 없습니다.

---

## 풀이 과정

### 문제 분석

문제에서 새로운 퍼즐 조각을 넣었을 때, 인접한 빈칸이 있으면 안되므로 사실상 게임 보드의 빈칸에 딱 맞는 조각의 개수를 구하는 문제로 볼 수 있다.

즉, 다음과 같은 로직으로 풀면 된다.

1. 연속된 빈칸 리스트, 연속된 조각 리스트를 만든다.
2. 각 조각을 전부 순회한다.
    1. 이미 사용한 빈칸이면 다음 빈칸으로
    2. 현재 조각이 빈칸에 넣을 수 있는지 확인한다.
    3. 넣을 수 있다면 조각의 크기를 정답에 더한다.
    4. 현재 빈칸을 사용 처리한다.

### Shape 클래스

리스트를 만들 때, Shape 클래스를 정의하여 저장하였다.

각 조각을 쉽게 다루기 위해서는 최소 직사각형 형태로 저장하는 것이 편리하다. 그래서 해당 조각의 형태를 저장하는 필드는 boolean[][]으로 지정하였고 이 조각의 최소 직사각형 형태의 크기는 x(행), y(열)로 지정하였다. 생성자에서는 shape를 받고 배열의 크기로 x, y값을 설정한다.

예를 들어, 문제의 예시의 1번 조각은 다음과 같이 표현 가능하다.

x = 3
y = 2

|   | 0 | 1 |
|---|---|---|
| 0 | F | T |
| 1 | T | T |
| 2 | F | T |

그리고 조각의 개수도 구해야 하므로 내부 메소드로 구현하였다.

#### 코드

```java
class Shape {
    private boolean[][] shape;
    private int x, y;

    public Shape(boolean[][] shape) {
        this.shape = shape;
        this.x = shape.length;
        this.y = shape[0].length;
    }

    // 조각의 개수 구하기
    public int count() {
        int result = 0;
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                if (shape[i][j]) result++;
            }
        }
        return result;
    }
}
```

### 회전 및 비교

Shape 클래스 내 메소드로 인자로 다른 Shape 클래스를 받고 비교하여 같은지 확인하는 메소드를 작성하였다.

조각을 회전시키기 위해서는 실제로 회전시키는 것보다 상대적인 좌표의 위치를 비교하는 것이 쉽다. 예를 들어, 3 × 2 크기의 조각을 비교할 때, 다음과 같은 4가지 케이스를 확인하면 된다. 각 숫자는 좌표를 확인하는 순서이다.

#### 0° 회전

|   | 0 | 1 |
|---|---|---|
| 0 | 1 | 2 |
| 1 | 3 | 4 |
| 2 | 5 | 6 |

#### 90° 회전

|   | 0 | 1 | 2 |
|---|---|---|---|
| 0 | 5 | 3 | 1 |
| 1 | 6 | 4 | 2 |

#### 180° 회전

|   | 0 | 1 |
|---|---|---|
| 0 | 6 | 5 |
| 1 | 4 | 3 |
| 2 | 2 | 1 |

#### 270° 회전

|   | 0 | 1 | 2 |
|---|---|---|---|
| 0 | 2 | 4 | 6 |
| 1 | 1 | 3 | 5 |

먼저 두 조각의 x와 y값을 비교하는데 x1 = x2, y1 = y2 이면 0°와 180° 회전을 확인하면 되고 x1 = y2, y1 = x2 이면 90°와 270° 회전을 확인하면 된다.

#### 코드(Shape 클래스 완성)

```java
class Shape {
    private boolean[][] shape;
    private int x, y;

    public Shape(boolean[][] shape) {
        this.shape = shape;
        this.x = shape.length;
        this.y = shape[0].length;
    }

    // 조각의 개수 구하기
    public int count() {
        int result = 0;
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                if (shape[i][j]) result++;
            }
        }
        return result;
    }

    // 모양 일치 확인
    public boolean isFit(Shape s) {
        boolean flag = true;

        if (this.x == s.x && this.y == s.y) {
            // 0° 회전
            loop:
            for (int i = 0; i < x; i++) {
                for (int j = 0; j < y; j++) {
                    if (this.shape[i][j] ^ s.shape[i][j]) {
                        flag = false;
                        break loop;
                    }
                }
            }
            if (flag) return true;

            flag = true;

            // 180° 회전
            loop:
            for (int i = 0; i < x; i++) {
                for (int j = 0; j < y; j++) {
                    if (this.shape[i][j] ^ s.shape[x - i - 1][y - j - 1]) {
                        flag = false;
                        break loop;
                    }
                }
            }
            if (flag) return true;
        }

        if (this.x == s.y && this.y == s.x) {
            flag = true;

            // 90° 회전
            loop:
            for (int i = 0; i < x; i++) {
                for (int j = 0; j < y; j++) {
                    if (this.shape[i][j] ^ s.shape[y - j - 1][i]) {
                        flag = false;
                        break loop;
                    }
                }
            }
            if (flag) return true;

            flag = true;

            // 270° 회전
            loop:
            for (int i = 0; i < x; i++) {
                for (int j = 0; j < y; j++) {
                    if (this.shape[i][j] ^ s.shape[j][x - i - 1]) {
                        flag = false;
                        break loop;
                    }
                }
            }
            if (flag) return true;
        }
        return false;
    }
}
```

### 조각 리스트 만들기(BFS)

빈칸 리스트와 조각 리스트는 둘 다 BFS로 구할 수 있다.

모든 보드의 칸을 순회하면서 그 칸을 확인해야 한다면 거기서부터 BFS를 수행하여 연속된 칸의 좌표를 전부 구하여 따로 저장한다. 주의해야할 점은 게임 보드와 테이블의 확인해야 하는 칸이 각각 0, 1로 다르다는 것인데 함수의 인자로 어떤 값이 이미 방문한 칸인지 입력을 받았다.

조각의 좌표를 구했다면 상대적인 좌표로 바꾸기 위해 각 좌표의 x, y 값을 각각 x의 최댓값, y의 최댓값을 빼서 해당 위치의 boolean[][] 배열의 값을 true로 변경하였다. boolean[][] 배열의 크기는 x, y 좌표의 최댓값과 최솟값을 빼면 된다.

이렇게 만든 boolean[][] 배열을 이용해서 Shape 클래스를 반환해주었다.

```java
private final int[] DX = {1, -1, 0, 0};
private final int[] DY = {0, 0, 1, -1};

int size; // 보드의 크기(solution에서 설정)

// visit: 방문 처리 시 어떤 값으로 변경할지 설정
private Shape bfs(int[][] board, int i, int j, int visit) {
    int minX = i, minY = j; // x, y 좌표의 최솟값
    int maxX = i, maxY = j; // x, y 좌표의 최댓값

    List<List<Integer>> list = new ArrayList<>(); // 좌표 리스트
    Deque<List<Integer>> queue = new ArrayDeque<>(); // 큐
    List<Integer> init = new ArrayList<>(); // 처음 좌표

    init.add(i);
    init.add(j);
    list.add(init);
    queue.add(init);
    board[i][j] = visit;

    // BFS
    while (!queue.isEmpty()) {
        List<Integer> cur = queue.poll();

        for (int k = 0; k < 4; k++) {
            int nx = cur.get(0) + DX[k];
            int ny = cur.get(1) + DY[k];
            if (0 > nx || nx >= size || 0 > ny || ny >= size || board[nx][ny] == visit) continue;
            // 최댓값, 최솟값을 갱신
            minX = Math.min(minX, nx);
            minY = Math.min(minY, ny);
            maxX = Math.max(maxX, nx);
            maxY = Math.max(maxY, ny);

            List<Integer> temp = new ArrayList<>(); // 새로 추가된 좌표
            temp.add(nx);
            temp.add(ny);
            list.add(temp);
            queue.add(temp);
            board[nx][ny] = visit; // 방문 처리
        }
    }

    boolean[][] shape = new boolean[maxX - minX + 1][maxY - minY + 1]; // 조각의 모양
    for (List<Integer> cur : list) {
        shape[cur.get(0) - minX][cur.get(1) - minY] = true;
    }
    return new Shape(shape);
}
```

### 맞는 조각의 개수 구하기

처음에 언급한 로직대로 조각의 개수를 구하면 된다.

```java
List<Shape> shapeList = new ArrayList<>(); // 빈칸 리스트
List<Shape> pieceList = new ArrayList<>(); // 조각 리스트

// BFS로 각 조각 구하기
// ...

int answer = 0;
boolean[] used = new boolean[shapeList.size()]; // 이미 사용한 조각인지 확인하는 배열

for (Shape piece : pieceList) {
    for (int i = 0; i < shapeList.size(); i++) {
        if (used[i]) continue; // 이미 사용했다면 넘어가기
        if (piece.isFit(shapeList.get(i))) { // 모양이 일치하는지 확인
            answer += piece.count();
            used[i] = true; // 사용 처리
            break;
        }
    }
}
```

### 정답

```java
import java.util.*;

class Solution {
    private final int[] DX = {1, -1, 0, 0};
    private final int[] DY = {0, 0, 1, -1};

    int size;

    class Shape {
        private boolean[][] shape;
        private int x, y;

        public Shape(boolean[][] shape) {
            this.shape = shape;
            this.x = shape.length;
            this.y = shape[0].length;
        }

        public boolean isFit(Shape s) {
            boolean flag = true;

            if (this.x == s.x && this.y == s.y) {
                loop:
                for (int i = 0; i < x; i++) {
                    for (int j = 0; j < y; j++) {
                        if (this.shape[i][j] ^ s.shape[i][j]) {
                            flag = false;
                            break loop;
                        }
                    }
                }
                if (flag) return true;

                flag = true;
                loop:
                for (int i = 0; i < x; i++) {
                    for (int j = 0; j < y; j++) {
                        if (this.shape[i][j] ^ s.shape[x - i - 1][y - j - 1]) {
                            flag = false;
                            break loop;
                        }
                    }
                }
                if (flag) return true;
            }

            if (this.x == s.y && this.y == s.x) {
                flag = true;
                loop:
                for (int i = 0; i < x; i++) {
                    for (int j = 0; j < y; j++) {
                        if (this.shape[i][j] ^ s.shape[y - j - 1][i]) {
                            flag = false;
                            break loop;
                        }
                    }
                }
                if (flag) return true;

                flag = true;
                loop:
                for (int i = 0; i < x; i++) {
                    for (int j = 0; j < y; j++) {
                        if (this.shape[i][j] ^ s.shape[j][x - i - 1]) {
                            flag = false;
                            break loop;
                        }
                    }
                }
                if (flag) return true;
            }

            return false;
        }

        public int count() {
            int result = 0;
            for (int i = 0; i < x; i++) {
                for (int j = 0; j < y; j++) {
                    if (shape[i][j]) result++;
                }
            }
            return result;
        }
    }

    public int solution(int[][] game_board, int[][] table) {
        this.size = game_board.length;
        List<Shape> shapeList = new ArrayList<>();
        List<Shape> pieceList = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (game_board[i][j] == 0) {
                    shapeList.add(bfs(game_board, i, j, 1));
                }

                if (table[i][j] == 1) {
                    pieceList.add(bfs(table, i, j, 0));
                }
            }
        }

        int answer = 0;
        boolean[] used = new boolean[shapeList.size()];

        for (Shape piece : pieceList) {
            for (int i = 0; i < shapeList.size(); i++) {
                if (used[i]) continue;
                if (piece.isFit(shapeList.get(i))) {
                    answer += piece.count();
                    used[i] = true;
                    break;
                }
            }
        }

        return answer;
    }

    private Shape bfs(int[][] board, int i, int j, int con) {
        int minX = i, minY = j;
        int maxX = i, maxY = j;

        List<List<Integer>> list = new ArrayList<>();
        Deque<List<Integer>> queue = new ArrayDeque<>();
        List<Integer> init = new ArrayList<>();

        init.add(i);
        init.add(j);
        list.add(init);
        queue.add(init);
        board[i][j] = con;

        while (!queue.isEmpty()) {
            List<Integer> cur = queue.poll();

            for (int k = 0; k < 4; k++) {
                int nx = cur.get(0) + DX[k];
                int ny = cur.get(1) + DY[k];
                if (0 > nx || nx >= size || 0 > ny || ny >= size || board[nx][ny] == con) continue;
                minX = Math.min(minX, nx);
                minY = Math.min(minY, ny);
                maxX = Math.max(maxX, nx);
                maxY = Math.max(maxY, ny);

                List<Integer> temp = new ArrayList<>();
                temp.add(nx);
                temp.add(ny);
                list.add(temp);
                queue.add(temp);
                board[nx][ny] = con;
            }
        }

        boolean[][] shape = new boolean[maxX - minX + 1][maxY - minY + 1];
        for (List<Integer> cur : list) {
            shape[cur.get(0) - minX][cur.get(1) - minY] = true;
        }

        return new Shape(shape);
    }
}
```

---