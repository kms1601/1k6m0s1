---
title: '[99클럽 코테 스터디] - 41일차 TIL'
description: '41일차 문제 [도둑질]'
date: '2024-08-31'
thumbnail: 'https://drive.google.com/thumbnail?id=1mDmYgm9XHrcPotgzaxnSPRSrteq3nNHv&sz=w1000'
hashtags: '99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL'
---

## 오늘의 문제 - 프로그래머스 Lv.4 [<a href="https://school.programmers.co.kr/learn/courses/30/lessons/42898" target="_blank" className="a-mdx">도둑질</a>]

### 문제 설명

도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.

![image1](https://grepp-programmers.s3.amazonaws.com/files/ybm/e7dd4f51c3/a228c73d-1cbe-4d59-bb5d-833fd18d3382.png)

각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.

각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

### 제한사항

- 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
- money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

### 입출력 예

| money        | return |
|--------------|--------|
| [1, 2, 3, 1] | 4      |

---

## 풀이 과정

### 털 수 있는 다음 집

지금 어떤 집(i)을 털었다고 가정해보자. 그렇다면 다음에 털 수 있는 집은 어떤 집일까? 바로 다음 집은 문제에서 나온대로 인접한 두 집을 털면 경보가 울리게 되기 때문에 털 수 없다. 즉, 바로 다음 집을 제외하고 뒤쪽에 있는 모든 집을 털 수 있다.

- 털 수 있는 다음 집: i + 2, i + 3, i + 4, i + 5, ...

i + 4과 이후의 집을 생각해보자. i + 4의 경우 i + 2를 경유해서 털 수 있다. i + 5의 경우 i + 2 또는 i + 3을 경유해서 털 수 있다. 이후의 집도 똑같은 논리로 2칸을 건너뛰거나 3칸을 건너뛰는 것을 조합하여 도달하는 경로를 구할 수 있다. 즉, 문제를 풀 때 2칸과 3칸을 건너 뛰는 경우를 생각하면 된다.

### 원형 배치

집이 일자 형태라면 첫번째 집부터 DP를 적용하여 구하면 되지만 원형 배치이기 때문에 좀 더 생각해 보아야한다. 첫번째 집을 털었다면 마지막 집은 첫번째 집과 인접하기 때문에 절대로 털 수 없다. 즉, 아래와 같은 두 가지 경우가 있다.

1. 첫번째 집을 털었을 때, 마지막 집은 털 수 없으므로 DP를 적용할 때 마지막 배열을 처리하지 않는다.
2. 첫번째 집을 털지 않았을 때, 마지막 집을 털 수 있으므로 DP를 적용할 때 마지막 배열을 처리한다.

### DP

DP를 사용하기 위해 길이가 집의 개수(n)인 배열을 만든다. DP 적용 시, 2칸 전 배열과 3칸 전 배열을 체크하므로 0, 1, 2번째 배열에 초기값을 준다. 여기서 첫번째 집 유무에 따라 초기값이 다르다.

1. 첫번째 집을 털었을 때, dp[0] = money[0], dp[1] = 0, dp[2] = money[0] + money[2];
2. 첫번째 집을 털지 않았을 때, dp[0] = 0, dp[1] = money[1], dp[2] = money[2];

최댓값 추적을 위해 money[1], money[0] + money[2]중 더 큰 값을 초기 최댓값으로 한다.

이제 각각의 경우에 대해 DP를 수행한다. 2칸 전 배열과 3칸 전 배열 중 더 큰 값에 현재 값을 더한 값을 현재 DP에 넣는다. 그렇게 구한 값으로 최댓값을 갱신한다. 첫번째 집을 턴 경우에서는 마지막 집을 수행하지 않는다.

### 정답

```java
class Solution {
    public int solution(int[] money) {
        int n = money.length;
        int max = Math.max(money[1], money[0] + money[2]); // 초기 최댓값
        int[] dp = new int[n];

        // 첫번째 집을 털었을 때
        dp[0] = money[0];
        dp[2] = money[0] + money[2];
        for (int i = 3; i < n - 1; i++) { // 첫번째 집을 털었다면 마지막 집은 DP를 수행하지 않는다.
            dp[i] = money[i] + Math.max(dp[i - 2], dp[i - 3]);
            max = Math.max(max, dp[i]);
        }

        // 첫번째 집을 털지 않았을 때
        dp[0] = 0;
        dp[1] = money[1];
        dp[2] = money[2];
        for (int i = 3; i < n; i++) { // 첫번째 집을 털지 않았다면 마지막 집도 DP를 수행한다.
            dp[i] = money[i] + Math.max(dp[i - 2], dp[i - 3]);
            max = Math.max(max, dp[i]);
        }

        return max;
    }
}
```

---