---
title: '[99클럽 코테 스터디] - 27일차 TIL'
description: '27일차 문제 [공 이동 시뮬레이션]'
date: '2024-08-17'
thumbnail: 'https://drive.google.com/thumbnail?id=1mDmYgm9XHrcPotgzaxnSPRSrteq3nNHv&sz=w1000'
hashtags: '99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL'
---

## 오늘의 문제 - 프로그래머스 Lv.3 [<a href="https://school.programmers.co.kr/learn/courses/30/lessons/87391" target="_blank" className="a-mdx">공 이동 시뮬레이션</a>]

### 문제 설명

**n**행 **m**열의 격자가 있습니다. 격자의 각 행은 0, 1, ..., **n-1**번의 번호, 그리고 각 열은 0, 1, ..., **m-1**번의 번호가 순서대로 매겨져 있습니다. 당신은 이 격자에 공을 하나 두고, 그 공에 다음과 같은 쿼리들을 날리고자 합니다.

- 열 번호가 감소하는 방향으로 **dx**칸 이동하는 쿼리 (**query(0, dx)**)
- 열 번호가 증가하는 방향으로 **dx**칸 이동하는 쿼리 (**query(1, dx)**)
- 행 번호가 감소하는 방향으로 **dx**칸 이동하는 쿼리 (**query(2, dx)**)
- 행 번호가 증가하는 방향으로 **dx**칸 이동하는 쿼리 (**query(3, dx)**)
- 단, 공은 격자 바깥으로 이동할 수 없으며, 목적지가 격자 바깥인 경우 공은 이동하다가 더 이상 이동할 수 없을 때 멈추게 됩니다. 예를 들어, 5행 × 4열 크기의 격자 내의 공이 3행 2열에 있을 때 **query(3, 10)** 쿼리를 받은 경우 공은 4행 2열에서 멈추게 됩니다. (격자의 크기가 5행 × 4열이므로, 0~4번 행과 0~3번 열로 격자가 구성되기 때문입니다.)

격자의 행의 개수 **n**, 열의 개수 **m**, 정수 **x**와 **y**, 그리고 쿼리들의 목록을 나타내는 2차원 정수 배열 **queries**가 매개변수로 주어집니다. **n × m**개의 가능한 시작점에 대해서 해당 시작점에 공을 두고 **queries** 내의 쿼리들을 순서대로 시뮬레이션했을 때, **x**행 **y**열에 도착하는 시작점의 개수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- 1 ≤ **n** ≤ 10⁹
- 1 ≤ **m** ≤ 10⁹
- 0 ≤ **x** < n
- 0 ≤ **y** < m
- 1 ≤ **queries**의 행의 개수 ≤ 200,000
    - **queries**의 각 행은 **[command,dx]** 두 정수로 이루어져 있습니다.
    - 0 ≤ **command** ≤ 3
    - 1 ≤ **dx** ≤ 10⁹
    - 이는 **query(command, dx)**를 의미합니다.

### 입출력 예

| n | m | x | y | queries                               | result |
|---|---|---|---|---------------------------------------|--------|
| 2 | 2 | 0 | 0 | [[2,1],[0,1],[1,1],[0,1],[2,1]]       | 4      |
| 2 | 5 | 0 | 1 | [[3,1],[2,2],[1,1],[2,3],[0,1],[2,1]] | 2      |

### 입출력 예 설명

#### 입출력 예 #1

- 다음 애니메이션은 4개의 가능한 시작점에 대한 모든 시뮬레이션을 나타낸 것입니다.

![image1](https://grepp-programmers.s3.amazonaws.com/production/file_resource/101/Ball_ex1.gif)

- 어떤 곳에서 출발하더라도 항상 0행 0열에 도착하기 때문에, 4를 return 해야 합니다.

#### 입출력 예 #2

- 다음 애니메이션은 10개의 가능한 시작점에 대한 모든 시뮬레이션을 나타낸 것입니다.

![image2](https://grepp-programmers.s3.amazonaws.com/production/file_resource/107/Ball_ex2_faster.gif)

- 0행 1열, 1행 1열에서 출발했을 때만 0행 1열에 도착하므로, 2를 return 해야 합니다.
---

## 풀이 과정

### 모든 위치 확인

바로 떠오르는 풀이법은 모든 좌표에 대해서 쿼리를 수행하고 주어진 좌표가 되는 위치를 전부 일일히 구하는 것이다. 하지만 이 풀이의 시간복잡도는 O(n * m * queries.length)가 되기 때문에 시간 안에 풀이할 수 없다.

### 역추적

주어진 쿼리를 반대로 수행하면서 어떤 좌표들이 현재 쿼리를 수행하였을 때, 주어진 좌표가 될 수 있는지 구하는 방법이 있다. 이 방법으로 하면 시간복잡도는 O(queries.length)이므로 충분히 가능한 풀이이다.

그렇다면, 어떠한 로직으로 이를 구할 수 있을까?

### 좌표의 범위

다음과 같이 5행 5열의 격자를 생각해보자

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ・ | ・ | ・ | ・ | ・ |
| 2 | ・ | ・ | ・ | ・ | ・ |
| 3 | ・ | ・ | ・ | ・ | ・ |
| 4 | ・ | ・ | ・ | ・ | ・ |

목표 좌표가 (2, 2)이고(채워진 원) 현재 쿼리가 (0, 2)라면 가능한 좌표(빈 원)는 다음과 같다. 이와 같이 목표 좌표가 가장자리가 아니면 가능한 좌표는 목표 좌표에서 쿼리를 반대로 수행한 좌표가 된다.

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ・ | ・ | ・ | ・ | ・ |
| 2 | ・ | ・ | ● | ・ | ○ |
| 3 | ・ | ・ | ・ | ・ | ・ |
| 4 | ・ | ・ | ・ | ・ | ・ |

목표 좌표가 (2, 3)이라면 가능한 좌표의 범위는 존재하지 않는다. 가능한 좌표가 격자를 벗어났기 때문이다.

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ・ | ・ | ・ | ・ | ・ |
| 2 | ・ | ・ | ・ | ● | ・ |
| 3 | ・ | ・ | ・ | ・ | ・ |
| 4 | ・ | ・ | ・ | ・ | ・ |

목표 좌표가 (2, 0)이라면 가능한 좌표는 다음과 같다. 이와 같이 목표 좌표가 움직이는 방향이 가장자리면 벽에 막혀 움직이지 못하는 경우가 추가된다.

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ・ | ・ | ・ | ・ | ・ |
| 2 | ◉ | ○ | ○ | ・ | ・ |
| 3 | ・ | ・ | ・ | ・ | ・ |
| 4 | ・ | ・ | ・ | ・ | ・ |

이는 행 방향 쿼리도 같은 방식으로 적용된다. 즉, 쿼리를 반대로 수행하여 가능한 좌표의 범위를 구할 수 있다.

또한, 쿼리는 행 또는 열 방향으로만 증가하고 격자는 직사각형 모양이므로 가능한 좌표의 범위는 직사각형 모양이 된다. 즉, 범위를 왼쪽 위 좌표, 오른쪽 아래 좌표로 나타낼 수 있고 가능한 좌표의 개수는 직사각형의 넓이로 알 수 있다.

가능한 좌표가 직사각형 범위로 표현되도 위에서 언급한 로직은 동일하게 적용할 수 있다. 예를 들어 현재 가능한 좌표 범위가 (1, 0), (2, 1)라고 가정하자.

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ● | ● | ・ | ・ | ・ |
| 2 | ● | ● | ・ | ・ | ・ |
| 3 | ・ | ・ | ・ | ・ | ・ |
| 4 | ・ | ・ | ・ | ・ | ・ |

- 쿼리가 (3, 2) 일 때

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ● | ● | ・ | ・ | ・ |
| 2 | ● | ● | ・ | ・ | ・ |
| 3 | ○ | ○ | ・ | ・ | ・ |
| 4 | ○ | ○ | ・ | ・ | ・ |

- 쿼리가 (0, 2) 일 때

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ◉ | ◉ | ○ | ○ | ・ |
| 2 | ◉ | ◉ | ○ | ○ | ・ |
| 3 | ・ | ・ | ・ | ・ | ・ |
| 4 | ・ | ・ | ・ | ・ | ・ |

- 쿼리가 (1, 2) 일 때

|   | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| 0 | ・ | ・ | ・ | ・ | ・ |
| 1 | ● | ● | ・ | ・ | ・ |
| 2 | ● | ● | ・ | ・ | ・ |
| 3 | ・ | ・ | ・ | ・ | ・ |
| 4 | ・ | ・ | ・ | ・ | ・ |

즉, 가능한 좌표가 얼마나 있든 (x1, y1), (x2, y2)의 좌표를 이용하여 같은 로직을 적용할 수 있다.

정리하자면

- 가능한 범위의 좌표는 왼쪽 위 좌표 (x1, y1) 오른쪽 아래 좌표 (x2, y2)로 표현 가능하다.
- 가장자리 유무와 쿼리에 따라 좌표의 변화가 다르다.
    - 쿼리가 0일 때
        - y2 = min(x2 + (수치), m - 1)
        - y1 == 0 이면 y1 = 0
        - y1 != 0 이면 y1 = y1 + (수치), y1이 m 이상이면 가능한 좌표 없음.
    - 쿼리가 1일 때
        - y1 = max(y1 - (수치), 0)
        - y2 == m - 1 이면 , y2 = m - 1
        - y2 != m - 1 이면 y2 = y2 - (수치), y2가 0 미만이면 가능한 좌표 없음.
    - 쿼리가 2일 때
        - x2 = min(x2 + (수치), n - 1)
        - x1 == 0 이면 x1 = 0
        - x1 != 0 이면 x1 = x1 + (수치), x1이 n 이상이면 가능한 좌표 없음.
    - 쿼리가 3일 때
        - x1 = max(x1 - (수치), 0)
        - x2 == n - 1 이면 , x2 = n - 1
        - x2 != n - 1 이면 x2 = x2 - (수치), x2가 0 미만이면 가능한 좌표 없음.
- 직사각형의 넓이 (x2 - x1 + 1) * (y2 - y1 + 1)로 좌표의 개수를 구한다.

위 로직을 코드로 작성하면 정답을 알 수 있다.

### 정답

```java
class Solution {
    public long solution(int n, int m, int x, int y, int[][] queries) {
        // 자료형에 주의
        long x1 = x, x2 = x;
        long y1 = y, y2 = y;

        for (int i = queries.length - 1; i >= 0; i--) {
            int[] query = queries[i];
            switch (query[0]) {
                case 0:
                    if (y1 != 0) {
                        y1 += query[1];
                        if (y1 >= m) return 0;
                    }
                    y2 += query[1];
                    y2 = y2 >= m ? m - 1 : y2;
                    break;
                case 1:
                    if (y2 != m - 1) {
                        y2 -= query[1];
                        if (y2 < 0) return 0;
                    }
                    y1 -= query[1];
                    y1 = y1 < 0 ? 0 : y1;
                    break;
                case 2:
                    if (x1 != 0) {
                        x1 += query[1];
                        if (x1 >= n) return 0;
                    }
                    x2 += query[1];
                    x2 = x2 >= n ? n - 1 : x2;
                    break;
                case 3:
                    if (x2 != n - 1) {
                        x2 -= query[1];
                        if (x2 < 0) return 0;
                    }
                    x1 -= query[1];
                    x1 = x1 < 0 ? 0 : x1;
            }
        }

        return (x2 - x1 + 1) * (y2 - y1 + 1);
    }
}
```

---

## 정리

사실 나는 이 문제를 풀 때, 자료형 오버플로우 때문에 실패하던 것을 풀이 로직의 문제라고 생각하여 30분 가량의 시간을 낭비했다. 다음부터는 로직이 아무리 생각해도 맞는데 틀린다면 자료형을 확인해 봐야겠다.

---