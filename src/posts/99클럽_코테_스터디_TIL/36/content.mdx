---
title: '[99클럽 코테 스터디] - 36일차 TIL'
description: '36일차 문제 [도미노]'
date: '2024-08-26'
thumbnail: 'https://drive.google.com/thumbnail?id=1mDmYgm9XHrcPotgzaxnSPRSrteq3nNHv&sz=w1000'
hashtags: '99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL'
---

## 오늘의 문제 - 백준 골드 V [<a href="https://www.acmicpc.net/problem/1552" target="_blank" className="a-mdx">도미노</a>]

### 문제

<img className="rounded-xl" src={"https://drive.google.com/thumbnail?id=1Eo40fv84hpZ7y-Ad3SDNXy8TJ_-r2eq1&sz=w1000"} alt={"image1"}/>

도미노는 위와 같이 생겼다.

세준이가 가지고 있는 도미노는 약간 다르다. 세준이는 도미노를 N2개 가지고 있다. 따라서 N=2라면, 세준이는 (1,1), (1,2), (2,1), (2,2) 이렇게 총 N2개를 가지고 있는 것이다.

세준이는 이 도미노를 가지고 도미노미도마도라는 게임을 하려고 한다. 이 게임은 김민오가 만들었다.

이 게임에서 도미노는 N*N크기의 보드에 놓여져 있다. i번째 행, j번째 열에는 (i,j)라고 쓰여 있는 도미노가 놓여져 있다. 플레이어는 도미노를 정확하게 N개를 골라야 하는데, 선택한 도미노를 두 개가 같은 행에서 고르고, 선택한 도미노를 같은 열에서 고르면 안 된다는 조건이 있다. 또, 고른 도미노를 가지고 사이클을 만들 수 있다. 사이클을 만드는 방법은, 도미노 A와 B가 있을 때, A의 두 번째 숫자와 B의 첫 번째 수가 같으면 된다. 그리고 사이클을 이루는 첫 번째 도미노의 처음 숫자와 마지막 도미노의 둘째 숫자가 같으면 된다.

예를 들어, (1,3), (3,2), (2,4), (4,1)을 골라서 사이클을 만들 수 있다.

N개의 도미노를 고르면 이러한 사이클이 한 개 또는 그 이상의 그룹이 나온다. (1,1)와 같은 도미노는 자기 자신으로 사이클을 이루므로 하나의 그룹이다.

게임의 조건 중에 각 행과 열에서 중복되면 안되는 조건이 있기 때문에, 항상 사이클을 이룰 수 있다.

모든 도미노는 그 뒷면에 숫자가 쓰여 있다. 이 게임에서 점수를 계산할 때는 자기가 고른 도미노의 뒷면에 쓰여 있는 수를 모두 곱한다. 그 다음에 만약 사이클 그룹의 개수가 짝수가 되면 그 수에 -1을 곱한다.

세준이는 자기가 이 게임에서 얻을 수 있는 최대 점수와 최소 점수가 궁금해 졌다.

도미노의 개수와 도미노 뒷면에 쓰여 있는 수가 주어질 때, 세준이가 얻을 수 있는 최대 점수와 최소 점수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 N이 주어진다. N은 6보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 도미노에 쓰여 있는 수가 주어진다. i행 j열에 쓰여 있는 수는 도미노 (i,j)의 뒷 면에 쓰여 있는 수이다. 도미노의 뒷면에는 0부터 9까지의 수와 A부터 I까지 알파벳 대문자가 쓰여 있고, A부터 I까지 문자가 의미하는 것은 -1부터 -9까지이다.

### 출력

첫째 줄에 세준이가 얻을 수 있는 최소 점수, 둘째 줄에 세준이가 얻을 수 있는 최대 점수를 출력한다.

### 예제

#### 입력 1

2
35
44

#### 출력 1

-12
20

#### 입력 2

5
00200
0B000
00020
10000
00001

#### 출력 2

-8
0

#### 예제 입력 3

3
12A
A12
2A1

#### 예제 출력 3

-1
8

#### 예제 입력 4

4
AAAA
BBBB
CCCC
DDDD

#### 예제 출력 4

-24
24

---

## 풀이 과정

개인적으로 지문 해석이 매우 어려웠던 문제였다. 중간에 어색한 표현이 있는데 다음과 같이 생각하면 된다.

플레이어는 도미노를 정확하게 N개를 골라야 하는데, 선택한 도미노를 두 개가 같은 행에서 고르고, 선택한 도미노를 같은 열에서 고르면 안 된다는 조건이 있다.
⭣
플레이어는 도미노를 정확하게 N개를 골라야 하는데, 모든 도미노의 첫번째 수가 서로 다르고 두번째 수도 서로 달라야 한다.
예를 들어, (1, 2) (2, 1)은 조건에 맞지만 (1, 2) (1, 1)은 첫번째 수가 같으므로 조건에 맞지 않다.

N개의 도미노를 고르면 이러한 사이클이 한 개 또는 그 이상의 그룹이 나온다.
⭣
이렇게 고른 N개의 도미노로 사이클을 만들면 1개 이상의 그룹이 나온다.
예를 들어, 고른 도미노가 (1, 1) (2, 3) (3, 2) (4, 4)라면 \<(1, 1)\> \<(2, 3) (3, 2)\> \<(4, 4)\>과 같이 3개의 사이클을 만들 수 있다.

### 모든 조합 구하기

행의 숫자가 겹치면 안되는 조건이 있으므로 각 행에서 1개씩 뽑아야하고 열도 동일하게 적용된다. 즉, 0행에서 도미노를 하나 고르고 다음 행에서 도미노를 하나 고르는 식으로 도미노를 고를 수 있다. 행은 1씩 증가시키면서 하나씩 뽑으면 겹치지 않고 열은 배열을 이용해서 겹치지 않게 뽑을 수 있다.

문제 조건에서 N은 6이하의 자연수이므로 모든 조합을 계산하고 그 중 최솟값, 최댓값을 구해도 풀이가 가능하다.

아래와 같은 코드로 재귀를 이용하여 조합을 구하였다. col은 boolean[N]으로 이미 뽑은 열인지 확인하는 배열이다.

```java
private static void choose(int[] result, int r, int c) {
    result[r] = c;
    col[c] = true;

    // 도미노를 N개 뽑았다면
    if (r == N - 1) {
        int score = // 점수 구하기
        min = Math.min(min, score);
        max = Math.max(max, score);
    } else {
        for (int i = 0; i < N; i++) {
            if (col[i]) continue; // 이미 뽑힌 열이면 넘어가기
            choose(result, r + 1, i);
        }
    }

    // 백트래킹
    result[r] = 0;
    col[c] = false;
}
```

### 사이클 개수 구하기

어떤 도미노와 연결되는 도미노는 반드시 1개밖에 없으므로 단순한 반복문으로 개수를 구할 수 있다.

```java
private static int countCycle(int[] arr) {
    boolean[] visit = new boolean[N];
    int count = 0;
    for (int i = 0; i < N; i++) {
        if (visit[i]) continue;
        count++;
        int cur = i;
        while (!visit[cur]) {
            visit[cur] = true;
            cur = arr[cur];
        }
    }
    return count;
}
```

### 정답

```java
import java.io.*;

public class Main {
    private static int N;
    private static int[][] dominoes;
    private static boolean[] col;
    private static int min = Integer.MAX_VALUE;
    private static int max = Integer.MIN_VALUE;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        col = new boolean[N];
        dominoes = new int[N][N];
        for (int i = 0; i < N; i++) {
            String input = br.readLine();
            for (int j = 0; j < N; j++) {
                char c = input.charAt(j);
                if ('A' <= c && c <= 'I') {
                    dominoes[i][j] = '@' - c; // 알파벳일 경우 (= 'A' - c - 1)
                } else {
                    dominoes[i][j] = c - '0';
                }
            }
        }

        // 0행에서 뽑는 도미노의 행을 1씩 증가시키면서 조합을 구한다.
        for (int i = 0; i < N; i++) {
            choose(new int[N], 0, i);
        }

        System.out.println(min);
        System.out.println(max);
    }

    private static void choose(int[] result, int r, int c) {
        result[r] = c;
        col[c] = true;

        if (r == N - 1) {
            // 사이클의 개수가 짝수이면 -1 곱하기
            int score = (countCycle(result) % 2 == 0 ? -1 : 1) * getScore(result);
            min = Math.min(min, score);
            max = Math.max(max, score);
        } else {
            for (int i = 0; i < N; i++) {
                if (col[i]) continue;
                choose(result, r + 1, i);
            }
        }

        result[r] = 0;
        col[c] = false;
    }

    private static int countCycle(int[] arr) {
        boolean[] visit = new boolean[N];
        int count = 0;
        for (int i = 0; i < N; i++) {
            if (visit[i]) continue;
            count++;
            int cur = i;
            while (!visit[cur]) {
                visit[cur] = true;
                cur = arr[cur];
            }
        }
        return count;
    }

    private static int getScore(int[] arr) {
        int result = 1;
        for (int i = 0; i < N; i++) {
            result *= dominoes[i][arr[i]];
        }
        return result;
    }
}
```

---