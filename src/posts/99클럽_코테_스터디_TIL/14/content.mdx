---
title: '[99클럽 코테 스터디] - 14일차 TIL'
description: '14일차 문제 [징검다리]'
date: '2024-08-04'
thumbnail: 'https://drive.google.com/thumbnail?id=1mDmYgm9XHrcPotgzaxnSPRSrteq3nNHv&sz=w1000'
hashtags: '99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL'
---

## 오늘의 문제 - 프로그래머스 Lv.4 [<a href="https://school.programmers.co.kr/learn/courses/30/lessons/43236" target="_blank" className="a-mdx">징검다리</a>]

### 문제 설명

출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.
예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.

| 제거한 바위의 위치 | 각 바위 사이의 거리   | 거리의 최솟값 |
|------------|---------------|---------|
| [21, 17]   | [2, 9, 3, 11] | 2       |
| [2, 21]    | [11, 3, 3, 8] | 3       |
| [2, 11]    | [14, 3, 4, 4] | 3       |
| [11, 21]   | [2, 12, 3, 8] | 2       |
| [2, 14]    | [11, 6, 4, 4] | 4       |

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
- 바위는 1개 이상 50,000개 이하가 있습니다.
- n 은 1 이상 **바위의 개수** 이하입니다.

### 입출력 예

| distance | rocks                | n | return |
|----------|----------------------|---|--------|
| 25       | [2, 14, 11, 21, 17]	 | 4 | 4      |

### 입출력 예 설명

문제에 나온 예와 같습니다.

---

## 풀이 과정

### 조합

가장 먼저 떠올릴 수 있는 풀이법은 조합을 이용하여 바위를 빼는 모든 경우의 수를 알아내고 거리를 전부 계산하여 거리가 가장 큰 값을 찾아내는 것이다. 하지만 문제의 조건에서 최대 경우의 수는 ₅₀₀₀₀C₂₅₀₀₀이다. 일반적인 계산기로는 계산할 수도 없는 매우 큰 값이다. Wolfram Alpha에서 계산해본 결과 약 1.13 × 10¹⁵⁰⁴⁹라는 천문학적인 숫자이다. 즉, 모든 경우의 수를 구하는 방법은 적절하지 않다.

### 관점을 바꾸기

그렇다면 다른 방법을 생각해야 한다. 일반적으로 생각하면 빼야하는 바위의 개수가 주어지고 이 값으로 최대 거리를 구하는 것이 목표이다. 하지만 역으로 생각하여 최대 거리가 주어졌을 때, 빼야하는 바위의 개수를 생각해 보면 어떨까? 최대 거리가 주어졌을 때, 모든 바위 간 거리가 최대 거리보다는 크거나 같아야한다. 즉, (이전 바위 위치) - (현재 바위 위치) ≥ (최대 거리)이여야 한다. 만약 그렇지 않다면, 현재 바위를 제거해야 한다는 의미이다.

즉, 다음과 같은 방식으로 최대 거리가 주어졌을 때, 빼야하는 바위의 개수를 구할 수 있다.

1. 시작점(0), 모든 바위, 도착점(distance)에 대해서 아래를 반복한다.
    1. (이전 바위 위치) - (현재 바위 위치)를 구한다.
    2. 이 값이 최대 거리보다 작다면 현재 바위를 제거한다.

이 방법으로 최대 거리를 이용하여 빼야하는 바위의 개수를 구할 수 있다.

### 순차 탐색

최대 거리의 범위는 1부터 distance까지이다. 즉, 1부터 distance까지 값을 올리면서 빼야하는 바위의 개수가 n이 되는 값을 찾으면 된다. 하지만 문제 조건에서 distance의 값은 최대 1,000,000,000이다. 즉 순차 탐색으로는 시간 초과가 발생한다.

### 이분 탐색

최대 거리가 증가할 수록 빼야하는 바위의 개수는 바위가 더 멀리 배치되어야 하므로 증가하게 된다. 반대로 최대 거리가 감소할 수록 빼야하는 바위의 개수는 감소하게 된다. 즉, 이분 탐색을 이용하여 최대 거리를 매우 효율적으로 알 수 있다. 정리하면

- 빼야하는 바위의 개수가 n보다 크면
    - 최대 거리를 줄인다.
- 빼야하는 바위의 개수가 n보다 작으면
    - 최대 거리를 늘린다.

다음을 생각하면서 이분 탐색으로 최대 거리를 구하면 된다.

### 정답

```java
import java.util.*;

class Solution {
    public int solution(int distance, int[] rocks, int n) {
        Arrays.sort(rocks); // rocks가 정렬이 안되어 있으므로 먼저 정렬해준다.
        int left = 0, right = distance;
        int answer = 0;
        // 이분 탐색
        while (left <= right) {
            int mid = (left + right) / 2;
            int prev = 0; // 이전 바위의 위치. 초기값은 시작점.
            int removed = 0; // 빼야하는 바위의 개수.
            for (int rock : rocks) {
                if (rock - prev < mid) removed++; // 두 바위의 거리가 최대 거리보다 작다면 현재 바위를 제거.
                else prev = rock; // 이상이면 이전 바위의 위치 갱신.

                if (removed > n)  break; // 제거된 바위가 n보다 커졌다면 더 이상 확인해볼 필요 X.
            }

            if (distance - prev < mid) removed++; // 도착점도 확인해 봐야 한다.

            if (removed > n) { // 제거된 바위가 n초과라면
                right = mid - 1;
            } else { // 이하라면
                answer = mid;
                left = mid + 1;
            }
        }
        return answer;
    }
}
```
---

## 정리

솔직히 이분 탐색이라는 힌트가 없었으면 푸는데 어려움이 많았을 것 같은 문제였다. 앞으로 문제 조건의 값이 매우 크다면 이분 탐색을 고려해 봐야겠다.

---